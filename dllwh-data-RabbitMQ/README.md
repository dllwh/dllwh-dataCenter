[TOC]

# RabbitMQ简介

&emsp;&emsp;**RabbitMQ** 是由Erlang语言开发完成的，实现了高级消息队列协议（AMQP）的开源消息代理软件，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

# 什么叫消息队列

&emsp;&emsp;RabbitMQ是一个消息代理：它接受和转发消息。这里简单说下什么是消息以及消息队列

> - 消息（Message）是指在应用间传送的数据。
> - 消息队列(Message Queue)是一种应用间的通信方式，消息发送后可以立即放回，由消息系统来确保消息的可靠性传递。消息发布者只管把消息发布到MQ中而不用管是谁来取，而消息使用者只管从MQ中获取消息而不管是谁发布的，这样一来，消息发布者跟使用者都不用知道对方的存在。

# RabbitMQ 相关概念

&emsp;&emsp; RabbitMQ 整体上就是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ模型更像是一种交换机模型。

|||
|---|---|
|**Connection**|网络连接，比如一个TCP连接。|
|**Channel**|信道，是建立在真实的TCP连接内的虚拟连接。<br/>&emsp;&emsp;不管是发布消息、订阅队列还是接收消息，都是通过信道完成。|
|**Message**||
|**Broker**|消息中间件的服务节点|
|**producer**|消息的生产者|
|**consumer**|消费者，就是接受消息的程序|
|**Exchange**|交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。|
|**Routing Key**|路由关键字，由生产者封装在消息头中，Exchange 根据这个关键字进投递|
|**Queue**|消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。<br/>&emsp;它是消息的容器，也是消息的终点。消息一直在队列里面，等待消费者连接到这个队列将其取走。<br/>&emsp;RabbitMQ 中消息都只能存储在队列中|
|**Binding**|绑定，用于消息队列和交换器之间的关联。|
|**Binding Key**|Message Queue 对接收消息的限制条件，由消费者在 Binding 时指定|

# RabbitMQ 运转过程

## 生产者发送消息

1. 生产者连接到 RabbitMQ Broker ，建立一连接(个Connection)，开启一个信道(Chanel)。
2. 生产者声明一个交换器并设置相关属性，例如交换器类型、是否持久化等。
3. 生产者声明一个队列并设置相关属性，例如是否排他、是否持久化、是否自动删除等。
4. 生产者通过路由键将交换器和队列绑定起来。
5. 生产者发送消息只RabbitMQ Broker，其中包含路由键、交换器等信息。
6. 相应的交换器根据接收到的路由键查找相匹配的队列。
7. 如果找到，则将生产者发送过来的消息存入相应的队列中。
8. 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者。
9. 关闭信道。
10. 断开连接。

## 消费者接收消息

1. 消费者连接 RabbitMQ Broker ，建立一连接(个Connection)，开启一个信道(Chanel)。
2. 消费者向 RabbitMQ Broker 请求消费相应队列中的信息，可能会设置相应的回调函数，以及做一些准备工作。
3. 等待RabbitMQ Broker 回应并投递相应队列中的信息，消费者接收消息。
4. 消费者确认(ack)接收到的消息。
5. RabbitMQ 从队列中删除相应已经被确认的消息。
6. 关闭信道。
7. 断开连接。